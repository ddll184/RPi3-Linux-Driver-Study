# 第4章学习笔记：字符设备驱动的测试与权限管理

## 摘要

本节学习的核心在于将理论付诸实践。我们成功将编写的 `hello_char` 字符驱动部署到 Raspberry Pi 3 硬件上，并完成了加载、测试和卸载的全过程。期间，我们遇到了关键的“Permission denied”问题，并通过在驱动层修改设备文件权限的正确方法，深入理解了 Linux 驱动与 VFS (虚拟文件系统) 之间的权限交互机制。

## 原理思维导图

设备文件权限的控制流程如下：

1.  **用户操作**: 用户在 shell 中执行 `cat /dev/hello_char`。
2.  **VFS 层介入**: 内核的 VFS 首先检查 `pi` 用户对 `/dev/hello_char` 文件是否有“读”权限。
    *   **默认情况**: `device_create` 创建的设备节点权限默认为 `0600` (仅 `root` 可读写)，因此 VFS 在此步拒绝访问，返回 `Permission denied`。
    *   **修复后**: 我们的驱动通过 `devnode` 回调，在 VFS 创建节点时就已告知内核此文件的模式应为 `0666` (所有人可读写)。因此，VFS 检查通过。
3.  **驱动函数调用**: VFS 权限检查通过后，调用与 `read` 操作关联的驱动函数，即 `hello_char_read()`。
4.  **驱动执行**: `hello_char_read()` 将内核数据通过 `copy_to_user` 返回给用户空间的 `cat` 程序。
5.  **数据显示**: `cat` 程序在终端上打印出从驱动收到的数据。

`devnode` 回调的角色就像是在设备节点“诞生”的那一刻，给它贴上一个“身份标签”（即文件权限），VFS 后续的所有操作都会依据这个标签来进行权限判断。

## 代码精华

解决设备文件权限问题的核心代码有两处：

1.  **`devnode` 回调函数的实现**：
    此函数定义了即将创建的设备节点应有的文件模式 (mode)。内核在调用 `device_create()` 的过程中会回调此函数，让我们有机会干预默认权限。

    ```c
    // devnode回调函数，用于设置设备文件权限
    static char *hello_char_devnode(const struct device *dev, umode_t *mode)
    {
        if (mode)
            *mode = 0666; // 设置权限为 rw-rw-rw-
        return NULL;
    }
    ```

2.  **在 `init` 函数中注册回调**：
    创建 `class` 之后，必须将我们实现的 `devnode` 函数指针赋值给 `class` 结构体的 `devnode` 成员，从而完成注册。

    ```c
    // 在 hello_char_init() 函数中...

    // 4. 创建设备类 (class)
    hello_class = class_create(CLASS_NAME);
    if (IS_ERR(hello_class)) {
        // ... 错误处理
    }
    pr_info("设备类创建成功\n");

    // 关键：设置 devnode 回调以修改设备文件权限
    hello_class->devnode = hello_char_devnode;

    // 5. 创建设备实例 (device)
    hello_device = device_create(hello_class, NULL, dev_num, NULL, DEVICE_NAME);
    // ... 
    ```

## 关联知识

本次实践是 `003_第一个字符驱动程序分析.md` 笔记中理论知识的延续和深化。之前我们学习了如何使用 `alloc_chrdev_region`, `cdev_add`, `class_create`, `device_create` 这些API“创建”一个设备。而这次，我们学会了如何“配置”这个被创建的设备，使其能以我们期望的方式（正确的权限）与用户空间交互。这标志着我们从“让驱动跑起来”迈向了“让驱动跑得好、跑得对”的新阶段。

## 实战记录

### 1. 驱动测试关键日志

以下 `dmesg` 日志展示了完整的驱动操作流程：加载、打开、写入、读取、关闭、卸载。

```
[114076.303558] 设备号分配成功. 主设备号=239, 次设备号=0
[114076.303670] 设备类创建成功
[114076.303959] 设备创建成功，位于 /dev/hello_char
[114118.309936] 设备已被打开
[114118.310023] 从用户接收到 6 字节数据: hello
[114118.310053] 设备已被关闭
[114128.780263] 设备已被打开
[114128.780372] 已发送 6 字节数据给用户
[114128.780472] 设备已被关闭
[114063.313128] hello_char 驱动已卸载
```

### 2. 问题排查 (Troubleshooting)

#### a. 驱动权限问题

-   **现象**: `echo "hello" > /dev/hello_char` 或 `cat /dev/hello_char` 报错 `Permission denied`。
-   **原因**: `device_create` 默认创建的设备文件权限为 `0600`，仅 `root` 可访问。同时，`sudo echo > file` 因为 shell 重定向的执行顺序问题也无法成功。
-   **解决方案**: 通过实现 `class->devnode` 回调函数，在驱动层将文件权限模式设置为 `0666`。

#### b. 编译错误：指针类型不兼容

-   **现象**: `error: assignment from incompatible pointer type`。
-   **原因**: `devnode` 回调函数的第一个参数应为 `const struct device *dev`，我们漏掉了 `const` 限定符。
-   **解决方案**: 为函数签名的第一个参数添加 `const`。

#### c. Git 推送失败

-   **现象 1**: `Password authentication is not supported`。
-   **原因**: GitHub 不再支持使用密码进行 Git 操作。
-   **解决方案**: 生成个人访问令牌 (PAT) 并用其代替密码。

-   **现象 2**: `The requested URL returned error: 403`。
-   **原因**: PAT 认证成功，但该 PAT 缺少向仓库写入的权限。
-   **解决方案**: 重新生成 PAT，确保勾选了 `repo` 权限范围 (scope)。最终通过 `git remote set-url` 命令将带 PAT 的 URL 配置到本地仓库，一劳永逸。
---
